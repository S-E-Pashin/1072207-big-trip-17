Добавлен notes.txt

npm i @babel/core@7.17.9
как будто зависло

npm install --save-dev @babel/core@7.17.9
Установилось основной пакет

Установите плагин @babel/preset-env. В нём содержатся инструкции в какой поддерживаемый код можно перевести новейшие конструкции.
npm install --save-dev @babel/preset-env@7.16.11

Создал файл настроек babel.config.json
Внес
{
       "presets": ["@babel/preset-env"]
     }


Установите лоадер babel-loader и подключите его в webpack.config.js.
npm install --save-dev babel-loader@8.2.4
Сделано

Добавьте в package.json секцию browserslist с указанием браузеров, которые мы хотим поддерживать. Именно на этот список будет смотреть плагин @babel/preset-env, подбирая инструкции для транспиляции.
  "browserslist": [
    "last 2 versions",
    "not dead",
    "not ie <= 11",
    "not op_mini all",
    "not < 0.25%"
  ],
  Сделано.


В индексе паблика задал адрес для скрипта. Адрес будет относительно будущего места расположения в сборке. А именно  <script src="./bundle.js"></script> так как сборка будет работать уже из папки build.



Первая ваша задача будет заключаться в «нарезке» вёрстки на отдельные компоненты (элементы интерфейса). Компоненты мы будем отрисовывать динамически — с помощью JavaScript. Для этого мы начнём знакомство с View и Presenter из MVP.

Ознакомьтесь с разметкой в директории markup.

Откройте файл public/index.html.
В этом файле приведена общая разметка страницы (layout) и присутствуют комментарии с описанием элементов, которые должны быть добавлены в данную область.
Перед закрывающим тегом body с помощью тега script подключите bundle.js.

Функцию для для отрисовки (вставки в DOM) компонентов писать не нужно, она уже есть в вашем репозитории.
Только разберитесь с её интерфейсом.

Создайте модули (отдельные файлы) и опишите в них классы для генерации DOM-элементов.
Эти модули — наши компоненты, или же View в рамках MVP. Поэтому:

для них нужно завести отдельную директорию src/view;
именуйте файлы как существительные;
для экспорта классов используйте экспорт по умолчанию.

На сколько компонентов и на какие именно компоненты разбить страницу решите самостоятельно,
 или воспользуйтесь предложенным списком:

фильтры;
сортировка;
форма создания;
форма редактирования; event event--edit
точка маршрута (в списке).

Заведите презентер, который будет отвечать за логику отрисовки компонентов, и отрисуйте компоненты по одному экземпляру на страницу,
кроме:
компонент «Точка маршрута» отрисовывается в списке 3 раза;
компонент «Форма редактирования» отрисовывает 1 раз, но должен располагаться первым в списке.
Запустите сервер для разработки. Откройте сайт локально в браузере.
Все компоненты должны быть корректно отрисованы. Для проверки сравните полученный результат с разметкой в директории markup.


main.js->// Файл- точка входа для js. Место запуска рендера для элеметов на странице. Включает в себе ипорт/ссылки на файлы-функции, заключает их в переменные и запускает функцию.
-presenter-header.js Файл для блока элементов
-view.js->Файл который имеет импорт по созданию дом элемета на основании шаблона, имеет шаблок и имеет класс с методами для создания элемента.
нет не так пока не понятно как.


Получается что если элемент отдельный на странице и не имеет вложенности то его можно и нужно отрисовывать из main.js если же это блок элементов то запуск его отрисовки происходит в main.js а тело отрисовки должно быть заключено в ...-presenter-header.js что по сути является или может являться функцией с функциями внутри.


sort родитель
<main class="page-body__page-main  page-main">
.trip-events

вью-


git rebase master из ветки
ошибка

git push origin module1-task3 --force

































































